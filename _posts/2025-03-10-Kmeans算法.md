---
title: 无监督聚类算法——Kmeans算法
date: 2025-03-10 07:54:00 +0800
categories: [机器学习]
tags: [无监督学习, 聚类算法, Kmeans, python]
description: Take you into the magical world of Kmeans algorithm.
media_subpath: /assets/2025/03/
image: /image_kmeans.png
---
## 介绍Kmeans算法

Kmeans算法是一种常见的无监督学习算法，主要用于聚类分析。其基本思想是将数据集分成K个簇，每个簇由一个质心代表。算法的步骤如下：

1. 随机选择K个初始质心。
2. 将每个数据点分配到最近的质心所属的簇。
3. 重新计算每个簇的质心。
4. 重复步骤2和3，直到质心不再发生变化或达到预定的迭代次数。

Kmeans算法的优点包括简单易懂、计算速度快、适用于大规模数据集。缺点是需要预先指定K值，对初始质心敏感，容易陷入局部最优解。

## 示例

以下是一个简单的Kmeans算法示例：

```python
import matplotlib.pyplot as plt
import seaborn as sns
sns.set(style="whitegrid")
```

### 1. 数据准备

运行以下代码可以生成一系列半随机的 x 和 y 坐标对。

```python
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.datasets import make_blobs

# 生成示例数据
points, cluster_indexs = make_blobs(n_samples=300, centers=4, cluster_std=0.8, random_state=0)
x = points[:, 0]
y = points[:, 1]

# 可视化原始数据
plt.scatter(x, y, s=50, alpha=0.7)

# 显示图形
plt.show()
```

![随机生成的一系列坐标点](/assets/2025/03/kmeans-output1.png)

### 2. 引入 Kmeans 聚类算法

使用 Kmeans 聚类算法将这些坐标点分为四组，并将聚类中心点渲染成红色。

```python
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.datasets import make_blobs

# 生成示例数据
points, cluster_indexs = make_blobs(n_samples=300, centers=4, cluster_std=0.8, random_state=0)
x = points[:, 0]
y = points[:, 1]

# 可视化原始数据
# plt.scatter(x, y, s=50, alpha=0.7)

# 使用K-means算法进行聚类
kmeans = KMeans(n_clusters=4, random_state=0)
kmeans.fit(points)

# 可视化聚类结果
# labels = kmeans.predict(points)
labels = kmeans.labels_
plt.scatter(x, y, c=labels, s=30, alpha=0.8, cmap='viridis')

# 标记聚类中心
centers = kmeans.cluster_centers_
plt.scatter(centers[:, 0], centers[:, 1], c='red', marker='x')

# 添加标题和坐标轴标签
plt.title('K-means Clustering')
plt.xlabel('Feature 1')
plt.ylabel('Feature 2')

# 显示图形
plt.show()
```

![使用 Kmeans 聚类算法将这些坐标点分为四组](/assets/2025/03/kmeans-output2.png)

在上述示例中，我们将数据集分成了4个簇，并输出了每个数据点的簇标签和质心坐标。

### 3. 如何确定正确的聚类数量？

试着将 n_clusters 调整为其他值，比如3或者5，看看在聚类数量不同的时候，这些点是如何分组的。

这也引入了一个新问题：怎么知道正确的聚类数量是多少？

手肘法（elbow method）将从 kmeans.inertia_ 获取的惯性（数据点到最近聚类中心点的平方距离和）作为聚类数量的函数来绘制。

```python
inertias = []

for i in range(1, 10):
    kmeans = KMeans(n_clusters=i, random_state=0)
    kmeans.fit(points)
    inertias.append(kmeans.inertia_)
    
plt.plot(range(1, 10), inertias, marker='o')

# 添加标题和坐标轴标签
plt.title('Elbow Method')
plt.xlabel('Number of clusters')
plt.ylabel('Inertia')

# 显示图形
plt.show()
```

![手肘法（elbow method）](/assets/2025/03/kmeans-output3.png)

然而，在现实中手肘法未必那么直观。好在以不同的方式对数据进行聚类，有时能获得不同的见解。

> 本文的全部代码可以 [点击获取](./Kmeans.ipynb).
{: .prompt-info }